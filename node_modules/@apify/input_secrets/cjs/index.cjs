const __ow_import = require('ow');
const __injectedOw = __ow_import.default || __ow_import;
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  decryptInputSecrets: () => decryptInputSecrets,
  encryptInputSecretValue: () => encryptInputSecretValue,
  encryptInputSecrets: () => encryptInputSecrets,
  getInputSchemaSecretFieldKeys: () => getInputSchemaSecretFieldKeys,
  isEncryptedValueForFieldSchema: () => isEncryptedValueForFieldSchema,
  isEncryptedValueForFieldType: () => isEncryptedValueForFieldType
});
module.exports = __toCommonJS(index_exports);

// src/input_secrets.ts
var import_node_crypto2 = require("crypto");
var import_ow = __toESM(require("ow"));
var import_utilities = require("@apify/utilities");

// src/field_schema_utils.ts
var import_node_crypto = __toESM(require("crypto"));
var OMIT_KEYS = /* @__PURE__ */ new Set(["title", "description", "sectionCaption", "sectionDescription", "nullable", "example", "prefill", "editor"]);
function normalizeFieldSchema(value) {
  if (Array.isArray(value)) {
    return value.map(normalizeFieldSchema);
  }
  if (value && typeof value === "object") {
    const result = {};
    Object.keys(value).filter((key) => !OMIT_KEYS.has(key)).sort().forEach((key) => {
      result[key] = normalizeFieldSchema(value[key]);
    });
    return result;
  }
  return value;
}
__name(normalizeFieldSchema, "normalizeFieldSchema");
function getFieldSchemaHash(fieldSchema) {
  try {
    const stringifiedSchema = JSON.stringify(normalizeFieldSchema(fieldSchema));
    return import_node_crypto.default.createHash("sha256").update(stringifiedSchema).digest("hex").slice(0, 10);
  } catch (err) {
    throw new Error(`The field schema could not be stringified for hash: ${err}`);
  }
}
__name(getFieldSchemaHash, "getFieldSchemaHash");

// src/input_secrets.ts
var ow = typeof __injectedOw === "undefined" ? import_ow.default : __injectedOw || import_ow.default;
var BASE64_REGEXP = /[-A-Za-z0-9+/]*={0,3}/;
var ENCRYPTED_STRING_VALUE_PREFIX = "ENCRYPTED_VALUE";
var ENCRYPTED_JSON_VALUE_PREFIX = "ENCRYPTED_JSON";
var ENCRYPTED_VALUE_REGEXP = new RegExp(`^(${ENCRYPTED_STRING_VALUE_PREFIX}|${ENCRYPTED_JSON_VALUE_PREFIX}):(?:(${BASE64_REGEXP.source}):)?(${BASE64_REGEXP.source}):(${BASE64_REGEXP.source})$`);
function getInputSchemaSecretFieldKeys(inputSchema) {
  return Object.keys(inputSchema.properties).filter((key) => !!inputSchema.properties[key].isSecret);
}
__name(getInputSchemaSecretFieldKeys, "getInputSchemaSecretFieldKeys");
function encryptInputSecretValue({ value, publicKey, schema }) {
  ow(value, ow.any(ow.string, ow.object));
  ow(publicKey, ow.object.instanceOf(import_node_crypto2.KeyObject));
  ow(schema, ow.optional.object);
  if (typeof value === "string") {
    const { encryptedValue: encryptedValue2, encryptedPassword: encryptedPassword2 } = (0, import_utilities.publicEncrypt)({ value, publicKey });
    return `${ENCRYPTED_STRING_VALUE_PREFIX}:${encryptedPassword2}:${encryptedValue2}`;
  }
  const schemaHash = schema ? getFieldSchemaHash(schema) : null;
  let valueStr;
  try {
    valueStr = JSON.stringify(value);
  } catch (err) {
    throw new Error(`The input value could not be stringified for encryption: ${err}`);
  }
  const { encryptedValue, encryptedPassword } = (0, import_utilities.publicEncrypt)({ value: valueStr, publicKey });
  return `${ENCRYPTED_JSON_VALUE_PREFIX}:${schemaHash ? `${schemaHash}:` : ""}${encryptedPassword}:${encryptedValue}`;
}
__name(encryptInputSecretValue, "encryptInputSecretValue");
function isEncryptedValueForFieldType(value, fieldType) {
  ow(value, ow.string);
  ow(fieldType, ow.string.oneOf(["string", "object", "array"]));
  const match = value.match(ENCRYPTED_VALUE_REGEXP);
  if (!match) return false;
  const [, prefix] = match;
  if (prefix === ENCRYPTED_STRING_VALUE_PREFIX && fieldType !== "string") return false;
  return true;
}
__name(isEncryptedValueForFieldType, "isEncryptedValueForFieldType");
function isEncryptedValueForFieldSchema(value, fieldSchema) {
  ow(value, ow.string);
  ow(fieldSchema, ow.object);
  const match = value.match(ENCRYPTED_VALUE_REGEXP);
  if (!match) return false;
  const [, prefix, schemaHash] = match;
  if (prefix !== ENCRYPTED_STRING_VALUE_PREFIX && prefix !== ENCRYPTED_JSON_VALUE_PREFIX) return false;
  if (schemaHash) {
    const fieldSchemaHash = getFieldSchemaHash(fieldSchema);
    return schemaHash === fieldSchemaHash;
  }
  return true;
}
__name(isEncryptedValueForFieldSchema, "isEncryptedValueForFieldSchema");
function encryptInputSecrets({ input, inputSchema, publicKey }) {
  ow(input, ow.object);
  ow(inputSchema, ow.object);
  ow(publicKey, ow.object.instanceOf(import_node_crypto2.KeyObject));
  const secretsInInputKeys = getInputSchemaSecretFieldKeys(inputSchema);
  if (secretsInInputKeys.length === 0) return input;
  const encryptedInput = {};
  for (const key of secretsInInputKeys) {
    const value = input[key];
    if (value && !(ow.isValid(value, ow.string) && ENCRYPTED_VALUE_REGEXP.test(value))) {
      try {
        encryptedInput[key] = encryptInputSecretValue({ value: input[key], publicKey, schema: inputSchema.properties[key] });
      } catch (err) {
        throw new Error(`The input field "${key}" could not be encrypted. Try updating the field's value in the input editor. Encryption error: ${err}`);
      }
    }
  }
  return { ...input, ...encryptedInput };
}
__name(encryptInputSecrets, "encryptInputSecrets");
function decryptInputSecrets({ input, privateKey }) {
  ow(input, ow.object);
  ow(privateKey, ow.object.instanceOf(import_node_crypto2.KeyObject));
  const decryptedInput = {};
  for (const [key, value] of Object.entries(input)) {
    if (typeof value === "string" && ENCRYPTED_VALUE_REGEXP.test(value)) {
      const match = value.match(ENCRYPTED_VALUE_REGEXP);
      if (!match) continue;
      const [, prefix, , encryptedPassword, encryptedValue] = match;
      try {
        const decryptedValue = (0, import_utilities.privateDecrypt)({ privateKey, encryptedPassword, encryptedValue });
        if (prefix === ENCRYPTED_STRING_VALUE_PREFIX) {
          decryptedInput[key] = decryptedValue;
        } else if (prefix === ENCRYPTED_JSON_VALUE_PREFIX) {
          decryptedInput[key] = JSON.parse(decryptedValue);
        }
      } catch (err) {
        throw new Error(`The input field "${key}" could not be decrypted. Try updating the field's value in the input editor. Decryption error: ${err}`);
      }
    }
  }
  return { ...input, ...decryptedInput };
}
__name(decryptInputSecrets, "decryptInputSecrets");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  decryptInputSecrets,
  encryptInputSecretValue,
  encryptInputSecrets,
  getInputSchemaSecretFieldKeys,
  isEncryptedValueForFieldSchema,
  isEncryptedValueForFieldType
});
//# sourceMappingURL=index.cjs.map