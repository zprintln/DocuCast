{"version":3,"sources":["../../src/input_secrets.ts","../../src/field_schema_utils.ts"],"sourcesContent":["import { KeyObject } from 'node:crypto';\n\nimport _testOw, { type Ow } from 'ow';\n\nimport { privateDecrypt, publicEncrypt } from '@apify/utilities';\n\nimport { getFieldSchemaHash } from './field_schema_utils';\n\n// eslint-disable-next-line no-underscore-dangle\ndeclare const __injectedOw: Ow;\n\nconst ow: Ow = typeof __injectedOw === 'undefined' ? _testOw : __injectedOw || _testOw;\n\nconst BASE64_REGEXP = /[-A-Za-z0-9+/]*={0,3}/;\n\n// The encrypted value has a prefix, optional schema hash, encrypted password and encrypted value.\n// - The prefix tells if the value is a string or a JSON object and needs to be parsed back after decryption.\n// - The schema hash is optional and is used to verify if the schema has changed since the value was encrypted.\n// - The encrypted password is used to decrypt the value.\n// - The encrypted value is the actual encrypted data.\n\n// used for backward compatibility with old encrypted string values\nconst ENCRYPTED_STRING_VALUE_PREFIX = 'ENCRYPTED_VALUE';\n// we use this for all types of encrypted values (string, object, array)\nconst ENCRYPTED_JSON_VALUE_PREFIX = 'ENCRYPTED_JSON';\n\n// All encrypted values must match this regular expression.\nconst ENCRYPTED_VALUE_REGEXP = new RegExp(`^(${ENCRYPTED_STRING_VALUE_PREFIX}|${ENCRYPTED_JSON_VALUE_PREFIX}):(?:(${BASE64_REGEXP.source}):)?(${BASE64_REGEXP.source}):(${BASE64_REGEXP.source})$`);\n\n/**\n * Get keys of secret fields from input schema\n */\nexport function getInputSchemaSecretFieldKeys(inputSchema: any): string[] {\n    return Object.keys(inputSchema.properties)\n        .filter((key) => !!inputSchema.properties[key].isSecret);\n}\n\n/**\n * Encrypts input secret value\n * Depending on the type of value, it returns either a string (for strings) or an object (for objects) with the `secret` key.\n */\nexport function encryptInputSecretValue<T extends string | object>(\n    { value, publicKey, schema }: { value: T, publicKey: KeyObject, schema?: Record<string, any> },\n): string {\n    ow(value, ow.any(ow.string, ow.object));\n    ow(publicKey, ow.object.instanceOf(KeyObject));\n    ow(schema, ow.optional.object);\n\n    // TODO to make string encryption compatible with current SDK, we need to use the old form.\n    //  Remove this once SDK is updated to use the new form\n    if (typeof value === 'string') {\n        const { encryptedValue, encryptedPassword } = publicEncrypt({ value, publicKey });\n        return `${ENCRYPTED_STRING_VALUE_PREFIX}:${encryptedPassword}:${encryptedValue}`;\n    }\n\n    const schemaHash = schema ? getFieldSchemaHash(schema) : null;\n\n    // We are encrypting the value as a JSON string, so we need to stringify it first.\n    let valueStr: string;\n    try {\n        valueStr = JSON.stringify(value);\n    } catch (err) {\n        throw new Error(`The input value could not be stringified for encryption: ${err}`);\n    }\n\n    const { encryptedValue, encryptedPassword } = publicEncrypt({ value: valueStr, publicKey });\n    return `${ENCRYPTED_JSON_VALUE_PREFIX}:${schemaHash ? `${schemaHash}:` : ''}${encryptedPassword}:${encryptedValue}`;\n}\n\n/**\n * Checks if the value is an encrypted value for a specific field type.\n * It validates the string value against the regular expression and checks the prefix.\n * @param value - encrypted value to check\n * @param fieldType - type of the field, can be 'string', 'object' or 'array'\n */\nexport function isEncryptedValueForFieldType(value: string, fieldType: 'string' | 'object' | 'array') {\n    ow(value, ow.string);\n    ow(fieldType, ow.string.oneOf(['string', 'object', 'array']));\n\n    const match = value.match(ENCRYPTED_VALUE_REGEXP);\n    if (!match) return false;\n\n    const [, prefix] = match;\n\n    // For backward compatibility, we allow the old prefix only for string values.\n    if (prefix === ENCRYPTED_STRING_VALUE_PREFIX && fieldType !== 'string') return false;\n\n    return true;\n}\n\n/**\n * Checks if the value is an encrypted value for a specific field schema.\n * It validates the string value against the regular expression and checks the schema hash in\n * the encrypted value against the hash of the field schema.\n * @param value - encrypted value to check\n * @param fieldSchema - schema of the field, used to get the hash\n */\nexport function isEncryptedValueForFieldSchema(value: string, fieldSchema: Record<string, any>) {\n    ow(value, ow.string);\n    ow(fieldSchema, ow.object);\n\n    const match = value.match(ENCRYPTED_VALUE_REGEXP);\n    if (!match) return false;\n\n    const [, prefix, schemaHash] = match;\n\n    if (prefix !== ENCRYPTED_STRING_VALUE_PREFIX && prefix !== ENCRYPTED_JSON_VALUE_PREFIX) return false;\n\n    if (schemaHash) {\n        const fieldSchemaHash = getFieldSchemaHash(fieldSchema);\n        return schemaHash === fieldSchemaHash;\n    }\n\n    return true;\n}\n\n/**\n * Encrypts actor input secrets\n */\nexport function encryptInputSecrets<T extends Record<string, any>>(\n    { input, inputSchema, publicKey }: { input: T, inputSchema: object, publicKey: KeyObject },\n): T {\n    ow(input, ow.object);\n    ow(inputSchema, ow.object);\n    ow(publicKey, ow.object.instanceOf(KeyObject));\n\n    const secretsInInputKeys = getInputSchemaSecretFieldKeys(inputSchema);\n    if (secretsInInputKeys.length === 0) return input;\n\n    const encryptedInput = {} as Record<string, any>;\n    for (const key of secretsInInputKeys) {\n        const value = input[key];\n        // NOTE: Skips already encrypted values. It can happens in case client already encrypted values, before\n        // sending them using API. Or input was takes from task, run console or scheduler, where input is stored encrypted.\n        if (value && !(ow.isValid(value, ow.string) && ENCRYPTED_VALUE_REGEXP.test(value))) {\n            try {\n                encryptedInput[key] = encryptInputSecretValue({ value: input[key], publicKey, schema: (inputSchema as any).properties[key] });\n            } catch (err) {\n                throw new Error(`The input field \"${key}\" could not be encrypted. Try updating the field's value in the input editor. `\n                    + `Encryption error: ${err}`);\n            }\n        }\n    }\n\n    return { ...input, ...encryptedInput };\n}\n\n/**\n * Decrypts actor input secrets\n * @param {Object} input\n * @param {KeyObject} privateKey\n * @returns Object\n */\nexport function decryptInputSecrets<T>(\n    { input, privateKey }: { input: T, privateKey: KeyObject },\n): T {\n    ow(input, ow.object);\n    ow(privateKey, ow.object.instanceOf(KeyObject));\n\n    const decryptedInput = {} as Record<string, any>;\n    for (const [key, value] of Object.entries(input)) {\n        if (typeof value === 'string' && ENCRYPTED_VALUE_REGEXP.test(value)) {\n            const match = value.match(ENCRYPTED_VALUE_REGEXP);\n            if (!match) continue;\n            const [, prefix, , encryptedPassword, encryptedValue] = match;\n            try {\n                const decryptedValue = privateDecrypt({ privateKey, encryptedPassword, encryptedValue });\n\n                if (prefix === ENCRYPTED_STRING_VALUE_PREFIX) {\n                    decryptedInput[key] = decryptedValue;\n                } else if (prefix === ENCRYPTED_JSON_VALUE_PREFIX) {\n                    // For JSON values, we need to parse the decrypted string into an object.\n                    decryptedInput[key] = JSON.parse(decryptedValue);\n                }\n            } catch (err) {\n                throw new Error(`The input field \"${key}\" could not be decrypted. Try updating the field's value in the input editor. `\n                + `Decryption error: ${err}`);\n            }\n        }\n    }\n\n    return { ...input, ...decryptedInput };\n}\n","import crypto from 'node:crypto';\n\n/**\n * These keys are omitted from the field schema normalization process\n * because they are not relevant for validation of values against the schema.\n */\nconst OMIT_KEYS = new Set(['title', 'description', 'sectionCaption', 'sectionDescription', 'nullable', 'example', 'prefill', 'editor']);\n\n/**\n * Normalizes the field schema by removing irrelevant keys and sorting the remaining keys.\n */\nfunction normalizeFieldSchema(value: any): any {\n    if (Array.isArray(value)) {\n        return value.map(normalizeFieldSchema);\n    }\n\n    if (value && typeof value === 'object') {\n        const result: Record<string, any> = {};\n        Object.keys(value)\n            .filter((key) => !OMIT_KEYS.has(key))\n            .sort()\n            .forEach((key) => {\n                result[key] = normalizeFieldSchema(value[key]);\n            });\n        return result;\n    }\n\n    return value;\n}\n\n/**\n * Generates a stable hash for the field schema.\n * @param fieldSchema\n */\nexport function getFieldSchemaHash(fieldSchema: Record<string, any>): string {\n    try {\n        const stringifiedSchema = JSON.stringify(normalizeFieldSchema(fieldSchema));\n        // Create a SHA-256 hash of the stringified schema and return the first 10 characters in hex.\n        return crypto.createHash('sha256').update(stringifiedSchema).digest('hex').slice(0, 10);\n    } catch (err) {\n        throw new Error(`The field schema could not be stringified for hash: ${err}`);\n    }\n}\n"],"mappings":"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","names":["encryptedValue","encryptedPassword"]}