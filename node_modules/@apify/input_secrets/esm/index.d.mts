import { KeyObject } from 'node:crypto';

/**
 * Get keys of secret fields from input schema
 */
declare function getInputSchemaSecretFieldKeys(inputSchema: any): string[];
/**
 * Encrypts input secret value
 * Depending on the type of value, it returns either a string (for strings) or an object (for objects) with the `secret` key.
 */
declare function encryptInputSecretValue<T extends string | object>({ value, publicKey, schema }: {
    value: T;
    publicKey: KeyObject;
    schema?: Record<string, any>;
}): string;
/**
 * Checks if the value is an encrypted value for a specific field type.
 * It validates the string value against the regular expression and checks the prefix.
 * @param value - encrypted value to check
 * @param fieldType - type of the field, can be 'string', 'object' or 'array'
 */
declare function isEncryptedValueForFieldType(value: string, fieldType: 'string' | 'object' | 'array'): boolean;
/**
 * Checks if the value is an encrypted value for a specific field schema.
 * It validates the string value against the regular expression and checks the schema hash in
 * the encrypted value against the hash of the field schema.
 * @param value - encrypted value to check
 * @param fieldSchema - schema of the field, used to get the hash
 */
declare function isEncryptedValueForFieldSchema(value: string, fieldSchema: Record<string, any>): boolean;
/**
 * Encrypts actor input secrets
 */
declare function encryptInputSecrets<T extends Record<string, any>>({ input, inputSchema, publicKey }: {
    input: T;
    inputSchema: object;
    publicKey: KeyObject;
}): T;
/**
 * Decrypts actor input secrets
 * @param {Object} input
 * @param {KeyObject} privateKey
 * @returns Object
 */
declare function decryptInputSecrets<T>({ input, privateKey }: {
    input: T;
    privateKey: KeyObject;
}): T;

export { decryptInputSecrets, encryptInputSecretValue, encryptInputSecrets, getInputSchemaSecretFieldKeys, isEncryptedValueForFieldSchema, isEncryptedValueForFieldType };
