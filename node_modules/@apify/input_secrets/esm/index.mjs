import __ow_import from 'ow';
const __injectedOw = __ow_import.default || __ow_import;
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/input_secrets.ts
import { KeyObject } from "crypto";
import _testOw from "ow";
import { privateDecrypt, publicEncrypt } from "@apify/utilities";

// src/field_schema_utils.ts
import crypto from "crypto";
var OMIT_KEYS = /* @__PURE__ */ new Set(["title", "description", "sectionCaption", "sectionDescription", "nullable", "example", "prefill", "editor"]);
function normalizeFieldSchema(value) {
  if (Array.isArray(value)) {
    return value.map(normalizeFieldSchema);
  }
  if (value && typeof value === "object") {
    const result = {};
    Object.keys(value).filter((key) => !OMIT_KEYS.has(key)).sort().forEach((key) => {
      result[key] = normalizeFieldSchema(value[key]);
    });
    return result;
  }
  return value;
}
__name(normalizeFieldSchema, "normalizeFieldSchema");
function getFieldSchemaHash(fieldSchema) {
  try {
    const stringifiedSchema = JSON.stringify(normalizeFieldSchema(fieldSchema));
    return crypto.createHash("sha256").update(stringifiedSchema).digest("hex").slice(0, 10);
  } catch (err) {
    throw new Error(`The field schema could not be stringified for hash: ${err}`);
  }
}
__name(getFieldSchemaHash, "getFieldSchemaHash");

// src/input_secrets.ts
var ow = typeof __injectedOw === "undefined" ? _testOw : __injectedOw || _testOw;
var BASE64_REGEXP = /[-A-Za-z0-9+/]*={0,3}/;
var ENCRYPTED_STRING_VALUE_PREFIX = "ENCRYPTED_VALUE";
var ENCRYPTED_JSON_VALUE_PREFIX = "ENCRYPTED_JSON";
var ENCRYPTED_VALUE_REGEXP = new RegExp(`^(${ENCRYPTED_STRING_VALUE_PREFIX}|${ENCRYPTED_JSON_VALUE_PREFIX}):(?:(${BASE64_REGEXP.source}):)?(${BASE64_REGEXP.source}):(${BASE64_REGEXP.source})$`);
function getInputSchemaSecretFieldKeys(inputSchema) {
  return Object.keys(inputSchema.properties).filter((key) => !!inputSchema.properties[key].isSecret);
}
__name(getInputSchemaSecretFieldKeys, "getInputSchemaSecretFieldKeys");
function encryptInputSecretValue({ value, publicKey, schema }) {
  ow(value, ow.any(ow.string, ow.object));
  ow(publicKey, ow.object.instanceOf(KeyObject));
  ow(schema, ow.optional.object);
  if (typeof value === "string") {
    const { encryptedValue: encryptedValue2, encryptedPassword: encryptedPassword2 } = publicEncrypt({ value, publicKey });
    return `${ENCRYPTED_STRING_VALUE_PREFIX}:${encryptedPassword2}:${encryptedValue2}`;
  }
  const schemaHash = schema ? getFieldSchemaHash(schema) : null;
  let valueStr;
  try {
    valueStr = JSON.stringify(value);
  } catch (err) {
    throw new Error(`The input value could not be stringified for encryption: ${err}`);
  }
  const { encryptedValue, encryptedPassword } = publicEncrypt({ value: valueStr, publicKey });
  return `${ENCRYPTED_JSON_VALUE_PREFIX}:${schemaHash ? `${schemaHash}:` : ""}${encryptedPassword}:${encryptedValue}`;
}
__name(encryptInputSecretValue, "encryptInputSecretValue");
function isEncryptedValueForFieldType(value, fieldType) {
  ow(value, ow.string);
  ow(fieldType, ow.string.oneOf(["string", "object", "array"]));
  const match = value.match(ENCRYPTED_VALUE_REGEXP);
  if (!match) return false;
  const [, prefix] = match;
  if (prefix === ENCRYPTED_STRING_VALUE_PREFIX && fieldType !== "string") return false;
  return true;
}
__name(isEncryptedValueForFieldType, "isEncryptedValueForFieldType");
function isEncryptedValueForFieldSchema(value, fieldSchema) {
  ow(value, ow.string);
  ow(fieldSchema, ow.object);
  const match = value.match(ENCRYPTED_VALUE_REGEXP);
  if (!match) return false;
  const [, prefix, schemaHash] = match;
  if (prefix !== ENCRYPTED_STRING_VALUE_PREFIX && prefix !== ENCRYPTED_JSON_VALUE_PREFIX) return false;
  if (schemaHash) {
    const fieldSchemaHash = getFieldSchemaHash(fieldSchema);
    return schemaHash === fieldSchemaHash;
  }
  return true;
}
__name(isEncryptedValueForFieldSchema, "isEncryptedValueForFieldSchema");
function encryptInputSecrets({ input, inputSchema, publicKey }) {
  ow(input, ow.object);
  ow(inputSchema, ow.object);
  ow(publicKey, ow.object.instanceOf(KeyObject));
  const secretsInInputKeys = getInputSchemaSecretFieldKeys(inputSchema);
  if (secretsInInputKeys.length === 0) return input;
  const encryptedInput = {};
  for (const key of secretsInInputKeys) {
    const value = input[key];
    if (value && !(ow.isValid(value, ow.string) && ENCRYPTED_VALUE_REGEXP.test(value))) {
      try {
        encryptedInput[key] = encryptInputSecretValue({ value: input[key], publicKey, schema: inputSchema.properties[key] });
      } catch (err) {
        throw new Error(`The input field "${key}" could not be encrypted. Try updating the field's value in the input editor. Encryption error: ${err}`);
      }
    }
  }
  return { ...input, ...encryptedInput };
}
__name(encryptInputSecrets, "encryptInputSecrets");
function decryptInputSecrets({ input, privateKey }) {
  ow(input, ow.object);
  ow(privateKey, ow.object.instanceOf(KeyObject));
  const decryptedInput = {};
  for (const [key, value] of Object.entries(input)) {
    if (typeof value === "string" && ENCRYPTED_VALUE_REGEXP.test(value)) {
      const match = value.match(ENCRYPTED_VALUE_REGEXP);
      if (!match) continue;
      const [, prefix, , encryptedPassword, encryptedValue] = match;
      try {
        const decryptedValue = privateDecrypt({ privateKey, encryptedPassword, encryptedValue });
        if (prefix === ENCRYPTED_STRING_VALUE_PREFIX) {
          decryptedInput[key] = decryptedValue;
        } else if (prefix === ENCRYPTED_JSON_VALUE_PREFIX) {
          decryptedInput[key] = JSON.parse(decryptedValue);
        }
      } catch (err) {
        throw new Error(`The input field "${key}" could not be decrypted. Try updating the field's value in the input editor. Decryption error: ${err}`);
      }
    }
  }
  return { ...input, ...decryptedInput };
}
__name(decryptInputSecrets, "decryptInputSecrets");
export {
  decryptInputSecrets,
  encryptInputSecretValue,
  encryptInputSecrets,
  getInputSchemaSecretFieldKeys,
  isEncryptedValueForFieldSchema,
  isEncryptedValueForFieldType
};
//# sourceMappingURL=index.mjs.map