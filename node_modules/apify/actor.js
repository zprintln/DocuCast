"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Actor = exports.EXIT_CODES = void 0;
const tslib_1 = require("tslib");
const node_crypto_1 = require("node:crypto");
const core_1 = require("@crawlee/core");
const utils_1 = require("@crawlee/utils");
const apify_client_1 = require("apify-client");
const ow_1 = tslib_1.__importDefault(require("ow"));
const consts_1 = require("@apify/consts");
const input_secrets_1 = require("@apify/input_secrets");
const log_1 = tslib_1.__importDefault(require("@apify/log"));
const timeout_1 = require("@apify/timeout");
const charging_js_1 = require("./charging.js");
const configuration_js_1 = require("./configuration.js");
const key_value_store_js_1 = require("./key_value_store.js");
const platform_event_manager_js_1 = require("./platform_event_manager.js");
const proxy_configuration_js_1 = require("./proxy_configuration.js");
const utils_js_1 = require("./utils.js");
/**
 * Exit codes for the Actor process.
 * The error codes must be in the range 1-128, to avoid collision with signal exits
 * and to ensure Docker will handle them correctly!
 * @internal should be removed if we decide to remove `Actor.main()`
 */
exports.EXIT_CODES = {
    SUCCESS: 0,
    ERROR_USER_FUNCTION_THREW: 91,
    ERROR_UNKNOWN: 92,
};
/**
 * `Actor` class serves as an alternative approach to the static helpers exported from the package. It allows to pass configuration
 * that will be used on the instance methods. Environment variables will have precedence over this configuration.
 * See {@link Configuration} for details about what can be configured and what are the default values.
 */
class Actor {
    constructor(options = {}) {
        /**
         * Configuration of this SDK instance (provided to its constructor). See {@link Configuration} for details.
         * @internal
         */
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Default {@link ApifyClient} instance.
         * @internal
         */
        Object.defineProperty(this, "apifyClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Default {@link EventManager} instance.
         * @internal
         */
        Object.defineProperty(this, "eventManager", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * Whether the Actor instance was initialized. This is set by calling {@link Actor.init}.
         */
        Object.defineProperty(this, "initialized", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * Set if the Actor called a method that requires the instance to be initialized, but did not do so.
         * A call to `init` after this warning is emitted is considered  an invalid state and will throw an error.
         */
        Object.defineProperty(this, "warnedAboutMissingInitCall", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**
         * Set if the Actor is currently rebooting.
         */
        Object.defineProperty(this, "isRebooting", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "chargingManager", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // use default configuration object if nothing overridden (it fallbacks to env vars)
        this.config =
            Object.keys(options).length === 0
                ? configuration_js_1.Configuration.getGlobalConfig()
                : new configuration_js_1.Configuration(options);
        this.apifyClient = this.newClient();
        this.eventManager = new platform_event_manager_js_1.PlatformEventManager(this.config);
        this.chargingManager = new charging_js_1.ChargingManager(this.config, this.apifyClient);
    }
    /**
     * Runs the main user function that performs the job of the Actor
     * and terminates the process when the user function finishes.
     *
     * **The `Actor.main()` function is optional** and is provided merely for your convenience.
     * It is mainly useful when you're running your code as an Actor on the [Apify platform](https://apify.com/actors).
     * However, if you want to use Apify SDK tools directly inside your existing projects, e.g.
     * running in an [Express](https://expressjs.com/) server, on
     * [Google Cloud functions](https://cloud.google.com/functions)
     * or [AWS Lambda](https://aws.amazon.com/lambda/), it's better to avoid
     * it since the function terminates the main process when it finishes!
     *
     * The `Actor.main()` function performs the following actions:
     *
     * - When running on the Apify platform (i.e. `APIFY_IS_AT_HOME` environment variable is set),
     *   it sets up a connection to listen for platform events.
     *   For example, to get a notification about an imminent migration to another server.
     *   See {@link Actor.events} for details.
     * - It invokes the user function passed as the `userFunc` parameter.
     * - If the user function returned a promise, waits for it to resolve.
     * - If the user function throws an exception or some other error is encountered,
     *   prints error details to console so that they are stored to the log.
     * - Exits the Node.js process, with zero exit code on success and non-zero on errors.
     *
     * The user function can be synchronous:
     *
     * ```js
     * await Actor.main(() => {
     *   // My synchronous function that returns immediately
     *   console.log('Hello world from Actor!');
     * });
     * ```
     *
     * If the user function returns a promise, it is considered asynchronous:
     * ```js
     * import { gotScraping } from 'got-scraping';
     *
     * await Actor.main(() => {
     *   // My asynchronous function that returns a promise
     *   return gotScraping('http://www.example.com').then((html) => {
     *     console.log(html);
     *   });
     * });
     * ```
     *
     * To simplify your code, you can take advantage of the `async`/`await` keywords:
     *
     * ```js
     * import { gotScraping } from 'got-scraping';
     *
     * await Actor.main(async () => {
     *   // My asynchronous function
     *   const html = await request('http://www.example.com');
     *   console.log(html);
     * });
     * ```
     *
     * @param userFunc User function to be executed. If it returns a promise,
     * the promise will be awaited. The user function is called with no arguments.
     * @param options
     * @ignore
     */
    async main(userFunc, options) {
        if (!userFunc || typeof userFunc !== 'function') {
            throw new Error(`First parameter for Actor.main() must be a function (was '${userFunc === null ? 'null' : typeof userFunc}').`);
        }
        return (async () => {
            await this.init(options);
            let ret;
            try {
                ret = (await userFunc());
                await this.exit(options);
            }
            catch (err) {
                log_1.default.exception(err, err.message);
                await this.exit({
                    exitCode: exports.EXIT_CODES.ERROR_USER_FUNCTION_THREW,
                });
            }
            return ret;
        })();
    }
    /**
     * @ignore
     */
    async init(options = {}) {
        if (this.initialized) {
            log_1.default.debug(`Actor SDK was already initialized`);
            return;
        }
        // If the warning about forgotten init call was emitted, we will not continue the init procedure.
        if (this.warnedAboutMissingInitCall) {
            throw new Error([
                'Actor.init() was called after a method that would access a storage client was used.',
                'This in an invalid state. Please make sure to call Actor.init() before such methods are called.',
            ].join('\n'));
        }
        this.initialized = true;
        (0, utils_js_1.checkCrawleeVersion)();
        log_1.default.info('System info', (0, utils_js_1.getSystemInfo)());
        (0, utils_js_1.printOutdatedSdkWarning)();
        // reset global config instance to respect APIFY_ prefixed env vars
        core_1.Configuration.globalConfig = configuration_js_1.Configuration.getGlobalConfig();
        if (this.isAtHome()) {
            this.config.set('availableMemoryRatio', 1);
            this.config.set('disableBrowserSandbox', true); // for browser launcher, adds `--no-sandbox` to args
            this.config.useStorageClient(this.apifyClient);
            this.config.useEventManager(this.eventManager);
        }
        else if (options.storage) {
            this.config.useStorageClient(options.storage);
        }
        // Init the event manager the config uses
        await this.config.getEventManager().init();
        log_1.default.debug(`Events initialized`);
        await (0, core_1.purgeDefaultStorages)({
            config: this.config,
            onlyPurgeOnce: true,
        });
        log_1.default.debug(`Default storages purged`);
        configuration_js_1.Configuration.storage.enterWith(this.config);
        await this.chargingManager.init();
        log_1.default.debug(`ChargingManager initialized`, this.chargingManager.getPricingInfo());
    }
    /**
     * @ignore
     */
    async exit(messageOrOptions, options = {}) {
        options =
            typeof messageOrOptions === 'string'
                ? { ...options, statusMessage: messageOrOptions }
                : { ...messageOrOptions, ...options };
        options.exit ?? (options.exit = true);
        options.exitCode ?? (options.exitCode = exports.EXIT_CODES.SUCCESS);
        options.timeoutSecs ?? (options.timeoutSecs = 30);
        const client = this.config.getStorageClient();
        const events = this.config.getEventManager();
        // Close the event manager and emit the final PERSIST_STATE event
        await events.close();
        log_1.default.debug(`Events closed`);
        // Emit the exit event
        events.emit("exit" /* EventType.EXIT */, options);
        // Wait for all event listeners to be processed
        log_1.default.debug(`Waiting for all event listeners to complete their execution (with ${options.timeoutSecs} seconds timeout)`);
        if (options.exit) {
            // `addTimeoutToPromise` is a cooperative timeout. This ensures that the process exits
            // after the timeout, even if the event listeners don't trigger the timeout.
            setTimeout(() => {
                process.exit(options.exitCode);
            }, options.timeoutSecs * 1000);
        }
        await (0, timeout_1.addTimeoutToPromise)(async () => {
            await events.waitForAllListenersToComplete();
            if (client.teardown) {
                let finished = false;
                setTimeout(() => {
                    if (!finished) {
                        log_1.default.info('Waiting for the storage to write its state to file system.');
                    }
                }, 1000);
                await client.teardown();
                finished = true;
            }
            if (options.statusMessage != null) {
                await this.setStatusMessage(options.statusMessage, {
                    isStatusMessageTerminal: true,
                    level: options.exitCode > 0 ? 'ERROR' : 'INFO',
                });
            }
        }, options.timeoutSecs * 1000, `Waiting for all event listeners to complete their execution timed out after ${options.timeoutSecs} seconds`).catch(() => {
            if (options.exit) {
                process.exit(options.exitCode);
            }
        });
        if (!options.exit) {
            return;
        }
        process.exit(options.exitCode);
    }
    /**
     * @ignore
     */
    async fail(messageOrOptions, options = {}) {
        return this.exit(messageOrOptions, { exitCode: 1, ...options });
    }
    /**
     * @ignore
     */
    on(event, listener) {
        this.config.getEventManager().on(event, listener);
    }
    /**
     * @ignore
     */
    off(event, listener) {
        this.config.getEventManager().off(event, listener);
    }
    /**
     * Runs an Actor on the Apify platform using the current user account (determined by the `APIFY_TOKEN` environment variable).
     *
     * The result of the function is an {@link ActorRun} object that contains details about the Actor run.
     *
     * If you want to run an Actor task rather than an Actor, please use the {@link Actor.callTask} function instead.
     *
     * For more information about Actors, read the [documentation](https://docs.apify.com/actor).
     *
     * **Example usage:**
     *
     * ```js
     * const run = await Actor.call('apify/hello-world', { myInput: 123 });
     * ```
     *
     * @param actorId
     *  Allowed formats are `username/actor-name`, `userId/actor-name` or Actor ID.
     * @param [input]
     *  Input for the Actor. If it is an object, it will be stringified to
     *  JSON and its content type set to `application/json; charset=utf-8`.
     *  Otherwise the `options.contentType` parameter must be provided.
     * @param [options]
     * @ignore
     */
    async call(actorId, input, options = {}) {
        const { token, ...rest } = options;
        const client = token ? this.newClient({ token }) : this.apifyClient;
        return client.actor(actorId).call(input, rest);
    }
    /**
     * Runs an Actor on the Apify platform using the current user account (determined by the `APIFY_TOKEN` environment variable),
     * unlike `Actor.call`, this method just starts the run without waiting for finish.
     *
     * The result of the function is an {@link ActorRun} object that contains details about the Actor run.
     *
     * For more information about Actors, read the
     * [documentation](https://docs.apify.com/actor).
     *
     * **Example usage:**
     *
     * ```js
     * const run = await Actor.start('apify/hello-world', { myInput: 123 });
     * ```
     *
     * @param actorId
     *  Allowed formats are `username/actor-name`, `userId/actor-name` or Actor ID.
     * @param [input]
     *  Input for the Actor. If it is an object, it will be stringified to
     *  JSON and its content type set to `application/json; charset=utf-8`.
     *  Otherwise the `options.contentType` parameter must be provided.
     * @param [options]
     * @ignore
     */
    async start(actorId, input, options = {}) {
        const { token, ...rest } = options;
        const client = token ? this.newClient({ token }) : this.apifyClient;
        return client.actor(actorId).start(input, rest);
    }
    /**
     * Aborts given Actor run on the Apify platform using the current user account (determined by the `APIFY_TOKEN` environment variable).
     *
     * The result of the function is an {@link ActorRun} object that contains details about the Actor run.
     *
     * For more information about Actors, read the
     * [documentation](https://docs.apify.com/actor).
     *
     * **Example usage:**
     *
     * ```js
     * const run = await Actor.abort(runId);
     * ```
     * @ignore
     */
    async abort(runId, options = {}) {
        const { token, statusMessage, ...rest } = options;
        const client = token ? this.newClient({ token }) : this.apifyClient;
        if (statusMessage) {
            await this.setStatusMessage(statusMessage, {
                isStatusMessageTerminal: true,
            });
        }
        return client.run(runId).abort(rest);
    }
    /**
     * Runs an actor task on the Apify platform using the current user account (determined by the `APIFY_TOKEN` environment variable).
     *
     * The result of the function is an {@link ActorRun} object that contains details about the Actor run.
     *
     * Note that an Actor task is a saved input configuration and options for an Actor.
     * If you want to run an Actor directly rather than an Actor task, please use the
     * {@link Actor.call} function instead.
     *
     * For more information about Actor tasks, read the [documentation](https://docs.apify.com/tasks).
     *
     * **Example usage:**
     *
     * ```js
     * const run = await Actor.callTask('bob/some-task');
     * ```
     *
     * @param taskId
     *  Allowed formats are `username/task-name`, `userId/task-name` or task ID.
     * @param [input]
     *  Input overrides for the Actor task. If it is an object, it will be stringified to
     *  JSON and its content type set to `application/json; charset=utf-8`.
     *  Provided input will be merged with Actor task input.
     * @param [options]
     * @ignore
     */
    async callTask(taskId, input, options = {}) {
        const { token, ...rest } = options;
        const client = token ? this.newClient({ token }) : this.apifyClient;
        return client.task(taskId).call(input, rest);
    }
    /**
     * Transforms this Actor run to an Actor run of a given Actor. The system stops the current container and starts
     * the new container instead. All the default storages are preserved and the new input is stored under the `INPUT-METAMORPH-1` key
     * in the same default key-value store.
     *
     * @param targetActorId
     *  Either `username/actor-name` or Actor ID of an Actor to which we want to metamorph.
     * @param [input]
     *  Input for the Actor. If it is an object, it will be stringified to
     *  JSON and its content type set to `application/json; charset=utf-8`.
     *  Otherwise, the `options.contentType` parameter must be provided.
     * @param [options]
     * @ignore
     */
    async metamorph(targetActorId, input, options = {}) {
        if (!this.isAtHome()) {
            log_1.default.warning('Actor.metamorph() is only supported when running on the Apify platform.');
            return;
        }
        const { customAfterSleepMillis = this.config.get('metamorphAfterSleepMillis'), ...metamorphOpts } = options;
        const runId = this.config.get('actorRunId');
        await this.apifyClient
            .run(runId)
            .metamorph(targetActorId, input, metamorphOpts);
        // Wait some time for container to be stopped.
        await (0, utils_1.sleep)(customAfterSleepMillis);
    }
    /**
     * Internally reboots this Actor. The system stops the current container and starts
     * a new container with the same run ID.
     * This can be used to get the Actor out of irrecoverable error state and continue where it left off.
     *
     * @ignore
     */
    async reboot(options = {}) {
        if (!this.isAtHome()) {
            log_1.default.warning('Actor.reboot() is only supported when running on the Apify platform.');
            return;
        }
        if (this.isRebooting) {
            log_1.default.debug('Actor is already rebooting, skipping the additional reboot call.');
            return;
        }
        this.isRebooting = true;
        // Waiting for all the listeners to finish, as `.reboot()` kills the container.
        await Promise.all([
            // `persistState` for individual RequestLists, RequestQueue... instances to be persisted
            ...this.config
                .getEventManager()
                .listeners("persistState" /* EventType.PERSIST_STATE */)
                .map(async (x) => x({})),
            // `migrating` to pause Apify crawlers
            ...this.config
                .getEventManager()
                .listeners("migrating" /* EventType.MIGRATING */)
                .map(async (x) => x({})),
        ]);
        const runId = this.config.get('actorRunId');
        await this.apifyClient.run(runId).reboot();
        // Wait some time for container to be stopped.
        const { customAfterSleepMillis = this.config.get('metamorphAfterSleepMillis'), } = options;
        await (0, utils_1.sleep)(customAfterSleepMillis);
    }
    /**
     * Creates an ad-hoc webhook for the current Actor run, which lets you receive a notification when the Actor run finished or failed.
     * For more information about Apify Actor webhooks, please see the [documentation](https://docs.apify.com/webhooks).
     *
     * Note that webhooks are only supported for Actors running on the Apify platform.
     * In local environment, the function will print a warning and have no effect.
     *
     * @param options
     * @returns The return value is the Webhook object.
     * For more information, see the [Get webhook](https://apify.com/docs/api/v2#/reference/webhooks/webhook-object/get-webhook) API endpoint.
     * @ignore
     */
    async addWebhook(options) {
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            eventTypes: ow_1.default.array.ofType(ow_1.default.string),
            requestUrl: ow_1.default.string,
            payloadTemplate: ow_1.default.optional.string,
            idempotencyKey: ow_1.default.optional.string,
        }));
        const { eventTypes, requestUrl, payloadTemplate, idempotencyKey } = options;
        if (!this.isAtHome()) {
            log_1.default.warning('Actor.addWebhook() is only supported when running on the Apify platform. The webhook will not be invoked.');
            return undefined;
        }
        const runId = this.config.get('actorRunId');
        if (!runId) {
            throw new Error(`Environment variable ${consts_1.ACTOR_ENV_VARS.RUN_ID} is not set!`);
        }
        return this.apifyClient.webhooks().create({
            isAdHoc: true,
            eventTypes,
            condition: {
                actorRunId: runId,
            },
            requestUrl,
            payloadTemplate,
            idempotencyKey,
        });
    }
    /**
     * Sets the status message for the current Actor run.
     *
     * @returns The return value is the Run object.
     * For more information, see the [Actor Runs](https://docs.apify.com/api/v2#/reference/actor-runs/) API endpoints.
     * @ignore
     */
    async setStatusMessage(statusMessage, options) {
        const { isStatusMessageTerminal, level } = options || {};
        (0, ow_1.default)(statusMessage, ow_1.default.string);
        (0, ow_1.default)(isStatusMessageTerminal, ow_1.default.optional.boolean);
        const loggedStatusMessage = `[Status message]: ${statusMessage}`;
        switch (level) {
            case 'DEBUG':
                log_1.default.debug(loggedStatusMessage);
                break;
            case 'WARNING':
                log_1.default.warning(loggedStatusMessage);
                break;
            case 'ERROR':
                log_1.default.error(loggedStatusMessage);
                break;
            default:
                log_1.default.info(loggedStatusMessage);
                break;
        }
        const client = this.config.getStorageClient();
        // just to be sure, this should be fast
        await (0, timeout_1.addTimeoutToPromise)(async () => client.setStatusMessage(statusMessage, {
            isStatusMessageTerminal,
            level,
        }), 1000, 'Setting status message timed out after 1s').catch((e) => log_1.default.warning(e.message));
        const runId = this.config.get('actorRunId');
        if (runId) {
            // just to be sure, this should be fast
            const run = await (0, timeout_1.addTimeoutToPromise)(async () => this.apifyClient.run(runId).get(), 1000, 'Getting the current run timed out after 1s').catch((e) => log_1.default.warning(e.message));
            if (run) {
                return run;
            }
        }
        return {};
    }
    /**
     * Stores an object or an array of objects to the default {@link Dataset} of the current Actor run.
     *
     * This is just a convenient shortcut for {@link Dataset.pushData}.
     * For example, calling the following code:
     * ```js
     * await Actor.pushData({ myValue: 123 });
     * ```
     *
     * is equivalent to:
     * ```js
     * const dataset = await Actor.openDataset();
     * await dataset.pushData({ myValue: 123 });
     * ```
     *
     * For more information, see {@link Actor.openDataset} and {@link Dataset.pushData}
     *
     * **IMPORTANT**: Make sure to use the `await` keyword when calling `pushData()`,
     * otherwise the Actor process might finish before the data are stored!
     *
     * @param item Object or array of objects containing data to be stored in the default dataset.
     * The objects must be serializable to JSON and the JSON representation of each object must be smaller than 9MB.
     * @param eventName If provided, the method will attempt to charge for the event for each pushed item.
     * @ignore
     */
    // eslint-disable-next-line consistent-return -- The `return` is inconsistent by design here (`ChargeResult` with `eventName` parameter)
    async pushData(item, eventName) {
        this._ensureActorInit('pushData');
        const dataset = await this.openDataset();
        const maxChargedCount = eventName !== undefined
            ? this.chargingManager.calculateMaxEventChargeCountWithinLimit(eventName)
            : Infinity;
        const toCharge = Array.isArray(item) ? item.length : 1;
        if (toCharge > maxChargedCount) {
            // Push as many items as we can charge for
            const items = Array.isArray(item) ? item : [item];
            await dataset.pushData(items.slice(0, maxChargedCount));
        }
        else {
            await dataset.pushData(item);
        }
        if (eventName) {
            return await this.chargingManager.charge({
                eventName,
                count: Math.min(toCharge, maxChargedCount),
            });
        }
    }
    /**
     * Opens a dataset and returns a promise resolving to an instance of the {@link Dataset} class.
     *
     * Datasets are used to store structured data where each object stored has the same attributes,
     * such as online store products or real estate offers.
     * The actual data is stored either on the local filesystem or in the cloud.
     *
     * For more details and code examples, see the {@link Dataset} class.
     *
     * @param [datasetIdOrName]
     *   ID or name of the dataset to be opened. If `null` or `undefined`,
     *   the function returns the default dataset associated with the Actor run.
     * @param [options]
     * @ignore
     */
    async openDataset(datasetIdOrName, options = {}) {
        (0, ow_1.default)(datasetIdOrName, ow_1.default.optional.string);
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            forceCloud: ow_1.default.optional.boolean,
        }));
        this._ensureActorInit('openDataset');
        return this._openStorage(core_1.Dataset, datasetIdOrName, options);
    }
    /**
     * Gets a value from the default {@link KeyValueStore} associated with the current Actor run.
     *
     * This is just a convenient shortcut for {@link KeyValueStore.getValue}.
     * For example, calling the following code:
     * ```js
     * const value = await Actor.getValue('my-key');
     * ```
     *
     * is equivalent to:
     * ```js
     * const store = await Actor.openKeyValueStore();
     * const value = await store.getValue('my-key');
     * ```
     *
     * To store the value to the default key-value store, you can use the {@link Actor.setValue} function.
     *
     * For more information, see  {@link Actor.openKeyValueStore}
     * and  {@link KeyValueStore.getValue}.
     *
     * @param key Unique record key.
     * @returns
     *   Returns a promise that resolves to an object, string
     *   or [`Buffer`](https://nodejs.org/api/buffer.html), depending
     *   on the MIME content type of the record, or `null`
     *   if the record is missing.
     * @ignore
     */
    async getValue(key) {
        this._ensureActorInit('getValue');
        const store = await this.openKeyValueStore();
        return store.getValue(key);
    }
    /**
     * Stores or deletes a value in the default {@link KeyValueStore} associated with the current Actor run.
     *
     * This is just a convenient shortcut for  {@link KeyValueStore.setValue}.
     * For example, calling the following code:
     * ```js
     * await Actor.setValue('OUTPUT', { foo: "bar" });
     * ```
     *
     * is equivalent to:
     * ```js
     * const store = await Actor.openKeyValueStore();
     * await store.setValue('OUTPUT', { foo: "bar" });
     * ```
     *
     * To get a value from the default key-value store, you can use the  {@link Actor.getValue} function.
     *
     * For more information, see  {@link Actor.openKeyValueStore}
     * and  {@link KeyValueStore.getValue}.
     *
     * @param key
     *   Unique record key.
     * @param value
     *   Record data, which can be one of the following values:
     *    - If `null`, the record in the key-value store is deleted.
     *    - If no `options.contentType` is specified, `value` can be any JavaScript object, and it will be stringified to JSON.
     *    - If `options.contentType` is set, `value` is taken as is, and it must be a `String` or [`Buffer`](https://nodejs.org/api/buffer.html).
     *   For any other value an error will be thrown.
     * @param [options]
     * @ignore
     */
    async setValue(key, value, options = {}) {
        this._ensureActorInit('setValue');
        const store = await this.openKeyValueStore();
        return store.setValue(key, value, options);
    }
    /**
     * Gets the Actor input value from the default {@link KeyValueStore} associated with the current Actor run.
     *
     * This is just a convenient shortcut for [`keyValueStore.getValue('INPUT')`](core/class/KeyValueStore#getValue).
     * For example, calling the following code:
     * ```js
     * const input = await Actor.getInput();
     * ```
     *
     * is equivalent to:
     * ```js
     * const store = await Actor.openKeyValueStore();
     * await store.getValue('INPUT');
     * ```
     *
     * Note that the `getInput()` function does not cache the value read from the key-value store.
     * If you need to use the input multiple times in your Actor,
     * it is far more efficient to read it once and store it locally.
     *
     * For more information, see  {@link Actor.openKeyValueStore}
     * and {@link KeyValueStore.getValue}.
     *
     * @returns
     *   Returns a promise that resolves to an object, string
     *   or [`Buffer`](https://nodejs.org/api/buffer.html), depending
     *   on the MIME content type of the record, or `null`
     *   if the record is missing.
     * @ignore
     */
    async getInput() {
        this._ensureActorInit('getInput');
        const inputSecretsPrivateKeyFile = this.config.get('inputSecretsPrivateKeyFile');
        const inputSecretsPrivateKeyPassphrase = this.config.get('inputSecretsPrivateKeyPassphrase');
        const input = await this.getValue(this.config.get('inputKey'));
        if (ow_1.default.isValid(input, ow_1.default.object.nonEmpty) &&
            inputSecretsPrivateKeyFile &&
            inputSecretsPrivateKeyPassphrase) {
            const privateKey = (0, node_crypto_1.createPrivateKey)({
                key: Buffer.from(inputSecretsPrivateKeyFile, 'base64'),
                passphrase: inputSecretsPrivateKeyPassphrase,
            });
            return (0, input_secrets_1.decryptInputSecrets)({ input, privateKey });
        }
        return input;
    }
    /**
     * Gets the Actor input value just like the {@link Actor.getInput} method,
     * but throws if it is not found.
     */
    async getInputOrThrow() {
        const input = await this.getInput();
        if (input == null) {
            throw new Error('Input does not exist');
        }
        return input;
    }
    /**
     * Opens a key-value store and returns a promise resolving to an instance of the {@link KeyValueStore} class.
     *
     * Key-value stores are used to store records or files, along with their MIME content type.
     * The records are stored and retrieved using a unique key.
     * The actual data is stored either on a local filesystem or in the Apify cloud.
     *
     * For more details and code examples, see the {@link KeyValueStore} class.
     *
     * @param [storeIdOrName]
     *   ID or name of the key-value store to be opened. If `null` or `undefined`,
     *   the function returns the default key-value store associated with the Actor run.
     * @param [options]
     * @ignore
     */
    async openKeyValueStore(storeIdOrName, options = {}) {
        (0, ow_1.default)(storeIdOrName, ow_1.default.optional.string);
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            forceCloud: ow_1.default.optional.boolean,
        }));
        this._ensureActorInit('openKeyValueStore');
        return this._openStorage(key_value_store_js_1.KeyValueStore, storeIdOrName, options);
    }
    /**
     * Opens a request queue and returns a promise resolving to an instance
     * of the {@link RequestQueue} class.
     *
     * {@link RequestQueue} represents a queue of URLs to crawl, which is stored either on local filesystem or in the cloud.
     * The queue is used for deep crawling of websites, where you start with several URLs and then
     * recursively follow links to other pages. The data structure supports both breadth-first
     * and depth-first crawling orders.
     *
     * For more details and code examples, see the {@link RequestQueue} class.
     *
     * @param [queueIdOrName]
     *   ID or name of the request queue to be opened. If `null` or `undefined`,
     *   the function returns the default request queue associated with the Actor run.
     * @param [options]
     * @ignore
     */
    async openRequestQueue(queueIdOrName, options = {}) {
        (0, ow_1.default)(queueIdOrName, ow_1.default.optional.string);
        (0, ow_1.default)(options, ow_1.default.object.exactShape({
            forceCloud: ow_1.default.optional.boolean,
        }));
        this._ensureActorInit('openRequestQueue');
        const queue = await this._openStorage(core_1.RequestQueue, queueIdOrName, options);
        // eslint-disable-next-line dot-notation
        queue['initialCount'] =
            (await queue.client.get())?.totalRequestCount ?? 0;
        return queue;
    }
    /**
     * Creates a proxy configuration and returns a promise resolving to an instance
     * of the {@link ProxyConfiguration} class that is already initialized.
     *
     * Configures connection to a proxy server with the provided options. Proxy servers are used to prevent target websites from blocking
     * your crawlers based on IP address rate limits or blacklists. Setting proxy configuration in your crawlers automatically configures
     * them to use the selected proxies for all connections.
     *
     * For more details and code examples, see the {@link ProxyConfiguration} class.
     *
     * ```js
     *
     * // Returns initialized proxy configuration class
     * const proxyConfiguration = await Actor.createProxyConfiguration({
     *     groups: ['GROUP1', 'GROUP2'] // List of Apify proxy groups
     *     countryCode: 'US'
     * });
     *
     * const crawler = new CheerioCrawler({
     *   // ...
     *   proxyConfiguration,
     *   requestHandler({ proxyInfo }) {
     *       const usedProxyUrl = proxyInfo.url; // Getting the proxy URL
     *   }
     * })
     *
     * ```
     *
     * For compatibility with existing Actor Input UI (Input Schema), this function
     * returns `undefined` when the following object is passed as `proxyConfigurationOptions`.
     *
     * ```
     * { useApifyProxy: false }
     * ```
     * @ignore
     */
    async createProxyConfiguration(proxyConfigurationOptions = {}) {
        // Compatibility fix for Input UI where proxy: None returns { useApifyProxy: false }
        // Without this, it would cause proxy to use the zero config / auto mode.
        const { useApifyProxy, ...options } = proxyConfigurationOptions;
        const dontUseApifyProxy = useApifyProxy === false;
        const dontUseCustomProxies = !proxyConfigurationOptions.proxyUrls;
        if (dontUseApifyProxy && dontUseCustomProxies) {
            return undefined;
        }
        const proxyConfiguration = new proxy_configuration_js_1.ProxyConfiguration(options, this.config);
        if (await proxyConfiguration.initialize()) {
            return proxyConfiguration;
        }
        return undefined;
    }
    /**
     * Charge for a specified number of events - sub-operations of the Actor.
     *
     * This method attempts to charge for the specified number of events, but may charge fewer
     * if doing so would exceed the total budget limit (`maxTotalChargeUsd`).
     *
     * @param options The name of the event to charge for and the number of events to be charged.
     * @ignore
     */
    async charge(options) {
        this._ensureActorInit('charge');
        return this.chargingManager.charge(options);
    }
    /**
     * Retrieve the charging manager to access granular pricing information.
     * @ignore
     */
    getChargingManager() {
        this._ensureActorInit('getChargingManager');
        return this.chargingManager;
    }
    /**
     * Modifies Actor env vars so parsing respects the structure of {@link ApifyEnv} interface.
     */
    getModifiedActorEnvVars() {
        const modifiedActorEnvVars = {};
        Object.entries(consts_1.ACTOR_ENV_VARS).forEach(([k, v]) => {
            // Prepend `ACTOR_` to env vars so ApifyEnv structure is preserved
            if (['ID', 'RUN_ID', 'TASK_ID'].includes(k)) {
                modifiedActorEnvVars[`ACTOR_${k}`] = v;
            }
            else {
                modifiedActorEnvVars[k] = v;
            }
        });
        return modifiedActorEnvVars;
    }
    /**
     * Returns a new {@link ApifyEnv} object which contains information parsed from all the Apify environment variables.
     *
     * For the list of the Apify environment variables, see
     * [Actor documentation](https://docs.apify.com/actor/run#environment-variables).
     * If some variables are not defined or are invalid, the corresponding value in the resulting object will be null.
     * @ignore
     */
    getEnv() {
        // NOTE: Don't throw if env vars are invalid to simplify local development and debugging of Actors
        const env = process.env || {};
        const envVars = {};
        for (const [shortName, fullName] of Object.entries({
            ...consts_1.APIFY_ENV_VARS,
            ...this.getModifiedActorEnvVars(),
        })) {
            const camelCaseName = (0, utils_1.snakeCaseToCamelCase)(shortName);
            let value = env[fullName];
            // Parse dates and integers.
            if (value && fullName.endsWith('_AT')) {
                const unix = Date.parse(value);
                value = unix > 0 ? new Date(unix) : undefined;
            }
            else if (consts_1.INTEGER_ENV_VARS.includes(fullName)) {
                value = parseInt(value, 10);
            }
            Reflect.set(envVars, camelCaseName, value || value === 0 ? value : null);
        }
        return envVars;
    }
    /**
     * Returns a new instance of the Apify API client. The `ApifyClient` class is provided
     * by the [apify-client](https://www.npmjs.com/package/apify-client)
     * NPM package, and it is automatically configured using the `APIFY_API_BASE_URL`, and `APIFY_TOKEN`
     * environment variables. You can override the token via the available options. That's useful
     * if you want to use the client as a different Apify user than the SDK internals are using.
     * @ignore
     */
    newClient(options = {}) {
        const { storageDir, ...storageClientOptions } = this.config.get('storageClientOptions');
        const { apifyVersion, crawleeVersion } = (0, utils_js_1.getSystemInfo)();
        return new apify_client_1.ApifyClient({
            baseUrl: this.config.get('apiBaseUrl'),
            token: this.config.get('token'),
            userAgentSuffix: [
                `SDK/${apifyVersion}`,
                `Crawlee/${crawleeVersion}`,
            ],
            ...storageClientOptions,
            ...options, // allow overriding the instance configuration
        });
    }
    /**
     * Returns `true` when code is running on Apify platform and `false` otherwise (for example locally).
     * @ignore
     */
    isAtHome() {
        return !!process.env[consts_1.APIFY_ENV_VARS.IS_AT_HOME];
    }
    /**
     * Easily create and manage state values. All state values are automatically persisted.
     *
     * Values can be modified by simply using the assignment operator.
     *
     * @param name The name of the store to use.
     * @param defaultValue If the store does not yet have a value in it, the value will be initialized with the `defaultValue` you provide.
     * @param options An optional object parameter where a custom `keyValueStoreName` and `config` can be passed in.
     */
    async useState(name, defaultValue = {}, options) {
        const kvStore = await key_value_store_js_1.KeyValueStore.open(options?.keyValueStoreName, {
            config: options?.config || configuration_js_1.Configuration.getGlobalConfig(),
        });
        return kvStore.getAutoSavedValue(name || 'APIFY_GLOBAL_STATE', defaultValue);
    }
    /**
     * Easily create and manage state values. All state values are automatically persisted.
     *
     * Values can be modified by simply using the assignment operator.
     *
     * @param name The name of the store to use.
     * @param defaultValue If the store does not yet have a value in it, the value will be initialized with the `defaultValue` you provide.
     * @param options An optional object parameter where a custom `keyValueStoreName` and `config` can be passed in.
     */
    static async useState(name, defaultValue = {}, options) {
        return Actor.getDefaultInstance().useState(name, defaultValue, options);
    }
    /**
     * Runs the main user function that performs the job of the Actor
     * and terminates the process when the user function finishes.
     *
     * **The `Actor.main()` function is optional** and is provided merely for your convenience.
     * It is mainly useful when you're running your code as an Actor on the [Apify platform](https://apify.com/actors).
     * However, if you want to use Apify SDK tools directly inside your existing projects, e.g.
     * running in an [Express](https://expressjs.com/) server, on
     * [Google Cloud functions](https://cloud.google.com/functions)
     * or [AWS Lambda](https://aws.amazon.com/lambda/), it's better to avoid
     * it since the function terminates the main process when it finishes!
     *
     * The `Actor.main()` function performs the following actions:
     *
     * - When running on the Apify platform (i.e. `APIFY_IS_AT_HOME` environment variable is set),
     *   it sets up a connection to listen for platform events.
     *   For example, to get a notification about an imminent migration to another server.
     *   See {@link Actor.events} for details.
     * - It invokes the user function passed as the `userFunc` parameter.
     * - If the user function returned a promise, waits for it to resolve.
     * - If the user function throws an exception or some other error is encountered,
     *   prints error details to console so that they are stored to the log.
     * - Exits the Node.js process, with zero exit code on success and non-zero on errors.
     *
     * The user function can be synchronous:
     *
     * ```js
     * await Actor.main(() => {
     *   // My synchronous function that returns immediately
     *   console.log('Hello world from Actor!');
     * });
     * ```
     *
     * If the user function returns a promise, it is considered asynchronous:
     * ```js
     * import { gotScraping } from 'got-scraping';
     *
     * await Actor.main(() => {
     *   // My asynchronous function that returns a promise
     *   return gotScraping('http://www.example.com').then((html) => {
     *     console.log(html);
     *   });
     * });
     * ```
     *
     * To simplify your code, you can take advantage of the `async`/`await` keywords:
     *
     * ```js
     * import { gotScraping } from 'got-scraping';
     *
     * await Actor.main(async () => {
     *   // My asynchronous function
     *   const html = await gotScraping('http://www.example.com');
     *   console.log(html);
     * });
     * ```
     *
     * @param userFunc User function to be executed. If it returns a promise,
     * the promise will be awaited. The user function is called with no arguments.
     * @param options
     */
    static async main(userFunc, options) {
        return Actor.getDefaultInstance().main(userFunc, options);
    }
    /**
     * Initializes the Actor, enabling support for the [Apify platform](https://apify.com/actors) dynamically
     * based on `APIFY_IS_AT_HOME` env var. If you are not running the code on Apify, you don't need to use it.
     * The method will switch storage client implementation automatically, so when you run on the Apify platform,
     * it will use its API instead of the default memory storage. It also increases the available memory ratio
     * from 25% to 100% on the platform.
     *
     * Calling `Actor.exit()` is required if you use the `Actor.init()` method, since it opens websocket connection
     * (see {@link Actor.events} for details), which needs to be terminated for the code to finish.
     *
     * ```js
     * import { gotScraping } from 'got-scraping';
     *
     * await Actor.init();
     *
     * const html = await gotScraping('http://www.example.com');
     * console.log(html);
     *
     * await Actor.exit();
     * ```
     *
     * @param options
     */
    static async init(options = {}) {
        return Actor.getDefaultInstance().init(options);
    }
    /**
     * Gracefully exits the Actor run with the provided status message and exit code.
     * @param messageOrOptions First parameter accepts either a string (a terminal status message) or an `ExitOptions` object.
     * @param options Second parameter accepts an `ExitOptions` object.
     */
    static async exit(messageOrOptions, options = {}) {
        return Actor.getDefaultInstance().exit(messageOrOptions, options);
    }
    /**
     * Calls `Actor.exit()` with `options.exitCode` set to `1`.
     * @param messageOrOptions First parameter accepts either a string (a terminal status message) or an `ExitOptions` object.
     * @param options Second parameter accepts an `ExitOptions` object.
     */
    static async fail(messageOrOptions, options = {}) {
        return Actor.getDefaultInstance().fail(messageOrOptions, options);
    }
    static on(event, listener) {
        Actor.getDefaultInstance().on(event, listener);
    }
    static off(event, listener) {
        Actor.getDefaultInstance().off(event, listener);
    }
    /**
     * Runs an Actor on the Apify platform using the current user account (determined by the `APIFY_TOKEN` environment variable).
     *
     * The result of the function is an {@link ActorRun} object that contains details about the Actor run.
     *
     * If you want to run an Actor task rather than an Actor, please use the {@link Actor.callTask} function instead.
     *
     * For more information about Actors, read the [documentation](https://docs.apify.com/actor).
     *
     * **Example usage:**
     *
     * ```js
     * const run = await Actor.call('apify/hello-world', { myInput: 123 });
     * ```
     *
     * @param actorId
     *  Allowed formats are `username/actor-name`, `userId/actor-name` or Actor ID.
     * @param [input]
     *  Input for the Actor. If it is an object, it will be stringified to
     *  JSON and its content type set to `application/json; charset=utf-8`.
     *  Otherwise the `options.contentType` parameter must be provided.
     * @param [options]
     */
    static async call(actorId, input, options = {}) {
        return Actor.getDefaultInstance().call(actorId, input, options);
    }
    /**
     * Runs an Actor task on the Apify platform using the current user account (determined by the `APIFY_TOKEN` environment variable).
     *
     * The result of the function is an {@link ActorRun} object that contains details about the Actor run.
     *
     * Note that an Actor task is a saved input configuration and options for an Actor.
     * If you want to run an Actor directly rather than an Actor task, please use the
     * {@link Actor.call} function instead.
     *
     * For more information about Actor tasks, read the [documentation](https://docs.apify.com/tasks).
     *
     * **Example usage:**
     *
     * ```js
     * const run = await Actor.callTask('bob/some-task');
     * ```
     *
     * @param taskId
     *  Allowed formats are `username/task-name`, `userId/task-name` or task ID.
     * @param [input]
     *  Input overrides for the Actor task. If it is an object, it will be stringified to
     *  JSON and its content type set to `application/json; charset=utf-8`.
     *  Provided input will be merged with Actor task input.
     * @param [options]
     */
    static async callTask(taskId, input, options = {}) {
        return Actor.getDefaultInstance().callTask(taskId, input, options);
    }
    /**
     * Runs an Actor on the Apify platform using the current user account (determined by the `APIFY_TOKEN` environment variable),
     * unlike `Actor.call`, this method just starts the run without waiting for finish.
     *
     * The result of the function is an {@link ActorRun} object that contains details about the Actor run.
     *
     * For more information about Actors, read the
     * [documentation](https://docs.apify.com/actor).
     *
     * **Example usage:**
     *
     * ```js
     * const run = await Actor.start('apify/hello-world', { myInput: 123 });
     * ```
     *
     * @param actorId
     *  Allowed formats are `username/actor-name`, `userId/actor-name` or Actor ID.
     * @param [input]
     *  Input for the Actor. If it is an object, it will be stringified to
     *  JSON and its content type set to `application/json; charset=utf-8`.
     *  Otherwise the `options.contentType` parameter must be provided.
     * @param [options]
     */
    static async start(actorId, input, options = {}) {
        return Actor.getDefaultInstance().start(actorId, input, options);
    }
    /**
     * Aborts given Actor run on the Apify platform using the current user account (determined by the `APIFY_TOKEN` environment variable).
     *
     * The result of the function is an {@link ActorRun} object that contains details about the Actor run.
     *
     * For more information about Actors, read the
     * [documentation](https://docs.apify.com/actor).
     *
     * **Example usage:**
     *
     * ```js
     * const run = await Actor.abort(runId);
     * ```
     */
    static async abort(runId, options = {}) {
        return Actor.getDefaultInstance().abort(runId, options);
    }
    /**
     * Transforms this Actor run to an Actor run of a given Actor. The system stops the current container and starts
     * the new container instead. All the default storages are preserved and the new input is stored under the `INPUT-METAMORPH-1` key
     * in the same default key-value store.
     *
     * @param targetActorId
     *  Either `username/actor-name` or Actor ID of an Actor to which we want to metamorph.
     * @param [input]
     *  Input for the Actor. If it is an object, it will be stringified to
     *  JSON and its content type set to `application/json; charset=utf-8`.
     *  Otherwise, the `options.contentType` parameter must be provided.
     * @param [options]
     */
    static async metamorph(targetActorId, input, options = {}) {
        return Actor.getDefaultInstance().metamorph(targetActorId, input, options);
    }
    /**
     * Internally reboots this Actor run. The system stops the current container and starts
     * a new container with the same run id.
     * This can be used to get the Actor out of irrecoverable error state and continue where it left off.
     */
    static async reboot(options = {}) {
        return Actor.getDefaultInstance().reboot(options);
    }
    /**
     * Creates an ad-hoc webhook for the current Actor run, which lets you receive a notification when the Actor run finished or failed.
     * For more information about Apify Actor webhooks, please see the [documentation](https://docs.apify.com/webhooks).
     *
     * Note that webhooks are only supported for Actors running on the Apify platform.
     * In local environment, the function will print a warning and have no effect.
     *
     * @param options
     * @returns The return value is the Webhook object.
     * For more information, see the [Get webhook](https://apify.com/docs/api/v2#/reference/webhooks/webhook-object/get-webhook) API endpoint.
     */
    static async addWebhook(options) {
        return Actor.getDefaultInstance().addWebhook(options);
    }
    /**
     * Sets the status message for the current Actor run.
     *
     * @param statusMessage The status message to set.
     * @param [options]
     * @param [options.isStatusMessageTerminal] If `true`, the status message will be marked as terminal.
     *          This is required for the last status message of the run. Default value is `false`.
     * @returns The return value is the Run object. When run locally, this method returns empty object (`{}`).
     * For more information, see the [Actor Runs](https://docs.apify.com/api/v2#/reference/actor-runs/) API endpoints.
     */
    static async setStatusMessage(statusMessage, options) {
        return Actor.getDefaultInstance().setStatusMessage(statusMessage, options);
    }
    /**
     * Stores an object or an array of objects to the default {@link Dataset} of the current Actor run.
     *
     * This is just a convenient shortcut for {@link Dataset.pushData}.
     * For example, calling the following code:
     * ```js
     * await Actor.pushData({ myValue: 123 });
     * ```
     *
     * is equivalent to:
     * ```js
     * const dataset = await Actor.openDataset();
     * await dataset.pushData({ myValue: 123 });
     * ```
     *
     * For more information, see {@link Actor.openDataset} and {@link Dataset.pushData}
     *
     * **IMPORTANT**: Make sure to use the `await` keyword when calling `pushData()`,
     * otherwise the Actor process might finish before the data are stored!
     *
     * @param item Object or array of objects containing data to be stored in the default dataset.
     * The objects must be serializable to JSON and the JSON representation of each object must be smaller than 9MB.
     * @param eventName If provided, the method will attempt to charge for the event for each pushed item.
     */
    static async pushData(item, eventName) {
        if (eventName === undefined) {
            return await Actor.getDefaultInstance().pushData(item);
        }
        return await Actor.getDefaultInstance().pushData(item, eventName);
    }
    /**
     * Opens a dataset and returns a promise resolving to an instance of the {@link Dataset} class.
     *
     * Datasets are used to store structured data where each object stored has the same attributes,
     * such as online store products or real estate offers.
     * The actual data is stored either on the local filesystem or in the cloud.
     *
     * For more details and code examples, see the {@link Dataset} class.
     *
     * @param [datasetIdOrName]
     *   ID or name of the dataset to be opened. If `null` or `undefined`,
     *   the function returns the default dataset associated with the Actor run.
     * @param [options]
     */
    static async openDataset(datasetIdOrName, options = {}) {
        return Actor.getDefaultInstance().openDataset(datasetIdOrName, options);
    }
    /**
     * Gets a value from the default {@link KeyValueStore} associated with the current Actor run.
     *
     * This is just a convenient shortcut for {@link KeyValueStore.getValue}.
     * For example, calling the following code:
     * ```js
     * const value = await Actor.getValue('my-key');
     * ```
     *
     * is equivalent to:
     * ```js
     * const store = await Actor.openKeyValueStore();
     * const value = await store.getValue('my-key');
     * ```
     *
     * To store the value to the default key-value store, you can use the {@link Actor.setValue} function.
     *
     * For more information, see  {@link Actor.openKeyValueStore}
     * and  {@link KeyValueStore.getValue}.
     *
     * @param key Unique record key.
     * @returns
     *   Returns a promise that resolves to an object, string
     *   or [`Buffer`](https://nodejs.org/api/buffer.html), depending
     *   on the MIME content type of the record, or `null`
     *   if the record is missing.
     */
    static async getValue(key) {
        return Actor.getDefaultInstance().getValue(key);
    }
    /**
     * Stores or deletes a value in the default {@link KeyValueStore} associated with the current Actor run.
     *
     * This is just a convenient shortcut for  {@link KeyValueStore.setValue}.
     * For example, calling the following code:
     * ```js
     * await Actor.setValue('OUTPUT', { foo: "bar" });
     * ```
     *
     * is equivalent to:
     * ```js
     * const store = await Actor.openKeyValueStore();
     * await store.setValue('OUTPUT', { foo: "bar" });
     * ```
     *
     * To get a value from the default key-value store, you can use the  {@link Actor.getValue} function.
     *
     * For more information, see  {@link Actor.openKeyValueStore}
     * and  {@link KeyValueStore.getValue}.
     *
     * @param key
     *   Unique record key.
     * @param value
     *   Record data, which can be one of the following values:
     *    - If `null`, the record in the key-value store is deleted.
     *    - If no `options.contentType` is specified, `value` can be any JavaScript object, and it will be stringified to JSON.
     *    - If `options.contentType` is set, `value` is taken as is, and it must be a `String` or [`Buffer`](https://nodejs.org/api/buffer.html).
     *   For any other value an error will be thrown.
     * @param [options]
     */
    static async setValue(key, value, options = {}) {
        return Actor.getDefaultInstance().setValue(key, value, options);
    }
    /**
     * Gets the Actor input value from the default {@link KeyValueStore} associated with the current Actor run.
     *
     * This is just a convenient shortcut for {@link KeyValueStore.getValue | `keyValueStore.getValue('INPUT')`}.
     * For example, calling the following code:
     * ```js
     * const input = await Actor.getInput();
     * ```
     *
     * is equivalent to:
     * ```js
     * const store = await Actor.openKeyValueStore();
     * await store.getValue('INPUT');
     * ```
     *
     * Note that the `getInput()` function does not cache the value read from the key-value store.
     * If you need to use the input multiple times in your Actor,
     * it is far more efficient to read it once and store it locally.
     *
     * For more information, see {@link Actor.openKeyValueStore} and {@link KeyValueStore.getValue}.
     *
     * @returns
     *   Returns a promise that resolves to an object, string
     *   or [`Buffer`](https://nodejs.org/api/buffer.html), depending
     *   on the MIME content type of the record, or `null`
     *   if the record is missing.
     */
    static async getInput() {
        return Actor.getDefaultInstance().getInput();
    }
    /**
     * Gets the Actor input value just like the {@link Actor.getInput} method,
     * but throws if it is not found.
     */
    static async getInputOrThrow() {
        return Actor.getDefaultInstance().getInputOrThrow();
    }
    /**
     * Opens a key-value store and returns a promise resolving to an instance of the {@link KeyValueStore} class.
     *
     * Key-value stores are used to store records or files, along with their MIME content type.
     * The records are stored and retrieved using a unique key.
     * The actual data is stored either on a local filesystem or in the Apify cloud.
     *
     * For more details and code examples, see the {@link KeyValueStore} class.
     *
     * @param [storeIdOrName]
     *   ID or name of the key-value store to be opened. If `null` or `undefined`,
     *   the function returns the default key-value store associated with the Actor run.
     * @param [options]
     */
    static async openKeyValueStore(storeIdOrName, options = {}) {
        return Actor.getDefaultInstance().openKeyValueStore(storeIdOrName, options);
    }
    /**
     * Opens a request queue and returns a promise resolving to an instance
     * of the {@link RequestQueue} class.
     *
     * {@link RequestQueue} represents a queue of URLs to crawl, which is stored either on local filesystem or in the cloud.
     * The queue is used for deep crawling of websites, where you start with several URLs and then
     * recursively follow links to other pages. The data structure supports both breadth-first
     * and depth-first crawling orders.
     *
     * For more details and code examples, see the {@link RequestQueue} class.
     *
     * @param [queueIdOrName]
     *   ID or name of the request queue to be opened. If `null` or `undefined`,
     *   the function returns the default request queue associated with the Actor run.
     * @param [options]
     */
    static async openRequestQueue(queueIdOrName, options = {}) {
        return Actor.getDefaultInstance().openRequestQueue(queueIdOrName, options);
    }
    /**
     * Creates a proxy configuration and returns a promise resolving to an instance
     * of the {@link ProxyConfiguration} class that is already initialized.
     *
     * Configures connection to a proxy server with the provided options. Proxy servers are used to prevent target websites from blocking
     * your crawlers based on IP address rate limits or blacklists. Setting proxy configuration in your crawlers automatically configures
     * them to use the selected proxies for all connections.
     *
     * For more details and code examples, see the {@link ProxyConfiguration} class.
     *
     * ```js
     *
     * // Returns initialized proxy configuration class
     * const proxyConfiguration = await Actor.createProxyConfiguration({
     *     groups: ['GROUP1', 'GROUP2'] // List of Apify proxy groups
     *     countryCode: 'US'
     * });
     *
     * const crawler = new CheerioCrawler({
     *   // ...
     *   proxyConfiguration,
     *   requestHandler({ proxyInfo }) {
     *       const usedProxyUrl = proxyInfo.url; // Getting the proxy URL
     *   }
     * })
     *
     * ```
     *
     * For compatibility with existing Actor Input UI (Input Schema), this function
     * returns `undefined` when the following object is passed as `proxyConfigurationOptions`.
     *
     * ```
     * { useApifyProxy: false }
     * ```
     */
    static async createProxyConfiguration(proxyConfigurationOptions = {}) {
        return Actor.getDefaultInstance().createProxyConfiguration(proxyConfigurationOptions);
    }
    /**
     * Charge for a specified number of events - sub-operations of the Actor.
     *
     * This method attempts to charge for the specified number of events, but may charge fewer
     * if doing so would exceed the total budget limit (`maxTotalChargeUsd`).
     *
     * @param options The name of the event to charge for and the number of events to be charged.
     */
    static async charge(options) {
        return Actor.getDefaultInstance().charge(options);
    }
    /**
     * Retrieve the charging manager to access granular pricing information.
     */
    static getChargingManager() {
        return Actor.getDefaultInstance().getChargingManager();
    }
    /**
     * Returns a new {@link ApifyEnv} object which contains information parsed from all the Apify environment variables.
     *
     * For the list of the Apify environment variables, see
     * [Actor documentation](https://docs.apify.com/actor/run#environment-variables).
     * If some of the variables are not defined or are invalid, the corresponding value in the resulting object will be null.
     */
    static getEnv() {
        return Actor.getDefaultInstance().getEnv();
    }
    /**
     * Returns a new instance of the Apify API client. The `ApifyClient` class is provided
     * by the [apify-client](https://www.npmjs.com/package/apify-client)
     * NPM package, and it is automatically configured using the `APIFY_API_BASE_URL`, and `APIFY_TOKEN`
     * environment variables. You can override the token via the available options. That's useful
     * if you want to use the client as a different Apify user than the SDK internals are using.
     */
    static newClient(options = {}) {
        return Actor.getDefaultInstance().newClient(options);
    }
    /**
     * Returns `true` when code is running on Apify platform and `false` otherwise (for example locally).
     */
    static isAtHome() {
        return Actor.getDefaultInstance().isAtHome();
    }
    /** Default {@link ApifyClient} instance. */
    static get apifyClient() {
        return Actor.getDefaultInstance().apifyClient;
    }
    /** Default {@link Configuration} instance. */
    static get config() {
        return Actor.getDefaultInstance().config;
    }
    /** @internal */
    static getDefaultInstance() {
        this._instance ?? (this._instance = new Actor());
        return this._instance;
    }
    async _openStorage(storageClass, id, options = {}) {
        const client = options.forceCloud ? this.apifyClient : undefined;
        return core_1.StorageManager.openStorage(storageClass, id, client, this.config);
    }
    _ensureActorInit(methodCalled) {
        // If we already warned the user once, don't do it again to prevent spam
        if (this.warnedAboutMissingInitCall) {
            return;
        }
        if (this.initialized) {
            return;
        }
        this.warnedAboutMissingInitCall = true;
        log_1.default.warning([
            `Actor.${methodCalled}() was called but the Actor instance was not initialized.`,
            'Did you forget to call Actor.init()?',
        ].join('\n'));
    }
}
exports.Actor = Actor;
//# sourceMappingURL=actor.js.map