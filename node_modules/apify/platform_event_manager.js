"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformEventManager = void 0;
const core_1 = require("@crawlee/core");
const ws_1 = require("ws");
const consts_1 = require("@apify/consts");
const utilities_1 = require("@apify/utilities");
const configuration_js_1 = require("./configuration.js");
/**
 * Gets an instance of a Node.js'
 * [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)
 * class that emits various events from the SDK or the Apify platform.
 * The event emitter is initialized by calling the {@link Actor.main} function.
 *
 * **Example usage:**
 *
 * ```javascript
 * Actor.on('cpuInfo', (data) => {
 *   if (data.isCpuOverloaded) console.log('Oh no, the CPU is overloaded!');
 * });
 * ```
 *
 * The following events are emitted:
 *
 * - `cpuInfo`: `{ "isCpuOverloaded": Boolean }`
 *   The event is emitted approximately every second
 *   and it indicates whether the Actor is using the maximum of available CPU resources.
 *   If that's the case, the Actor should not add more workload.
 *   For example, this event is used by the {@link AutoscaledPool} class.
 * - `migrating`: `void`
 *   Emitted when the Actor running on the Apify platform is going to be migrated to another worker server soon.
 *   You can use it to persist the state of the Actor and gracefully stop your in-progress tasks,
 *   so that they are not interrupted by the migration.
 *   For example, this is used by the {@link RequestList} class.
 * - `aborting`: `void`
 *   When a user aborts an Actor run on the Apify platform, they can choose to abort gracefully to allow
 *   the Actor some time before getting killed. This graceful abort emits the `aborting` event which the SDK
 *   uses to gracefully stop running crawls and you can use it to do your own cleanup as well.
 * - `persistState`: `{ "isMigrating": Boolean }`
 *   Emitted in regular intervals (by default 60 seconds) to notify all components of Apify SDK that it is time to persist
 *   their state, in order to avoid repeating all work when the Actor restarts.
 *   This event is automatically emitted together with the `migrating` event,
 *   in which case the `isMigrating` flag is set to `true`. Otherwise the flag is `false`.
 *   Note that the `persistState` event is provided merely for user convenience,
 *   you can achieve the same effect using `setInterval()` and listening for the `migrating` event.
 */
class PlatformEventManager extends core_1.EventManager {
    constructor(config = configuration_js_1.Configuration.getGlobalConfig()) {
        super();
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: config
        });
        /** Websocket connection to Actor events. */
        Object.defineProperty(this, "eventsWs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    /**
     * Initializes `Actor.events` event emitter by creating a connection to a websocket that provides them.
     * This is an internal function that is automatically called by `Actor.main()`.
     */
    async init() {
        if (this.initialized) {
            return;
        }
        await super.init();
        const eventsWsUrl = this.config.get('actorEventsWsUrl');
        // Locally there is no web socket to connect, so just print a log message.
        if (!eventsWsUrl) {
            this.log.debug(`Environment variable ${consts_1.ACTOR_ENV_VARS.EVENTS_WEBSOCKET_URL} is not set, no events from Apify platform will be emitted.`);
            return;
        }
        this.createWebSocketConnection(eventsWsUrl);
    }
    createWebSocketConnection(eventsWsUrl) {
        this.eventsWs = new ws_1.WebSocket(eventsWsUrl);
        this.eventsWs.on('message', (message) => {
            if (!message)
                return;
            try {
                const { name, data } = JSON.parse(String(message));
                this.events.emit(name, data);
                if (name === consts_1.ACTOR_EVENT_NAMES.MIGRATING) {
                    (0, utilities_1.betterClearInterval)(this.intervals.persistState); // Don't send any other persist state event.
                    this.events.emit("persistState" /* EventType.PERSIST_STATE */, {
                        isMigrating: true,
                    });
                }
            }
            catch (err) {
                this.log.exception(err, 'Cannot parse Actor event');
            }
        });
        this.eventsWs.on('error', (err) => {
            // Don't print this error as this happens in the case of very short Actor.main().
            if (err.message ===
                'WebSocket was closed before the connection was established')
                return;
            this.log.exception(err, 'web socket connection failed');
        });
        this.eventsWs.on('close', () => {
            this.log.debug('web socket has been closed');
            this.eventsWs = undefined;
        });
    }
    /**
     * Closes websocket providing events from Actor infrastructure and also stops sending internal events
     * of Apify package such as `persistState`.
     * This is automatically called at the end of `Actor.main()`.
     */
    async close() {
        if (!this.initialized) {
            return;
        }
        await super.close();
        this.eventsWs?.close();
    }
}
exports.PlatformEventManager = PlatformEventManager;
//# sourceMappingURL=platform_event_manager.js.map