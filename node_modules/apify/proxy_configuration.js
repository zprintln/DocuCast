"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyConfiguration = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@crawlee/core");
const utils_1 = require("@crawlee/utils");
const ow_1 = tslib_1.__importDefault(require("ow"));
const consts_1 = require("@apify/consts");
const utilities_1 = require("@apify/utilities");
const actor_js_1 = require("./actor.js");
const configuration_js_1 = require("./configuration.js");
// https://docs.apify.com/proxy/datacenter-proxy#username-parameters
const MAX_SESSION_ID_LENGTH = 50;
const CHECK_ACCESS_REQUEST_TIMEOUT_MILLIS = 4000;
const CHECK_ACCESS_MAX_ATTEMPTS = 2;
const COUNTRY_CODE_REGEX = /^[A-Z]{2}$/;
/**
 * Configures connection to a proxy server with the provided options. Proxy servers are used to prevent target websites from blocking
 * your crawlers based on IP address rate limits or blacklists. Setting proxy configuration in your crawlers automatically configures
 * them to use the selected proxies for all connections. You can get information about the currently used proxy by inspecting
 * the {@link ProxyInfo} property in your crawler's page function. There, you can inspect the proxy's URL and other attributes.
 *
 * The proxy servers are managed by [Apify Proxy](https://docs.apify.com/proxy). To be able to use Apify Proxy,
 * you need an Apify account and access to the selected proxies. If you provide no configuration option,
 * the proxies will be managed automatically using a smart algorithm.
 *
 * If you want to use your own proxies, use the {@link ProxyConfigurationOptions.proxyUrls} option. Your list of proxy URLs will
 * be rotated by the configuration if this option is provided.
 *
 * **Example usage:**
 *
 * ```javascript
 *
 * const proxyConfiguration = await Actor.createProxyConfiguration({
 *   groups: ['GROUP1', 'GROUP2'] // List of Apify Proxy groups
 *   countryCode: 'US',
 * });
 *
 * const crawler = new CheerioCrawler({
 *   // ...
 *   proxyConfiguration,
 *   requestHandler({ proxyInfo }) {
 *      const usedProxyUrl = proxyInfo.url; // Getting the proxy URL
 *   }
 * })
 *
 * ```
 * @category Scaling
 */
class ProxyConfiguration extends core_1.ProxyConfiguration {
    /**
     * @internal
     */
    constructor(options = {}, config = configuration_js_1.Configuration.getGlobalConfig()) {
        const { proxyUrls, newUrlFunction, ...rest } = options;
        super({
            proxyUrls,
            newUrlFunction,
            ['validateRequired']: false,
        });
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: config
        });
        Object.defineProperty(this, "groups", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "countryCode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "password", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "hostname", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "port", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "usesApifyProxy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        (0, ow_1.default)(rest, ow_1.default.object.exactShape({
            groups: ow_1.default.optional.array.ofType(ow_1.default.string.matches(consts_1.APIFY_PROXY_VALUE_REGEX)),
            apifyProxyGroups: ow_1.default.optional.array.ofType(ow_1.default.string.matches(consts_1.APIFY_PROXY_VALUE_REGEX)),
            countryCode: ow_1.default.optional.string.matches(COUNTRY_CODE_REGEX),
            apifyProxyCountry: ow_1.default.optional.string.matches(COUNTRY_CODE_REGEX),
            password: ow_1.default.optional.string,
            tieredProxyUrls: ow_1.default.optional.array.ofType(ow_1.default.array.ofType(ow_1.default.string)),
            tieredProxyConfig: ow_1.default.optional.array.ofType(ow_1.default.object),
        }));
        const { groups = [], apifyProxyGroups = [], countryCode, apifyProxyCountry, password = config.get('proxyPassword'), tieredProxyConfig, tieredProxyUrls, } = options;
        this.tieredProxyUrls ?? (this.tieredProxyUrls = tieredProxyUrls);
        if (tieredProxyConfig) {
            this.tieredProxyUrls = this._generateTieredProxyUrls(tieredProxyConfig, options);
        }
        const groupsToUse = groups.length ? groups : apifyProxyGroups;
        const countryCodeToUse = countryCode || apifyProxyCountry;
        const hostname = config.get('proxyHostname');
        const port = config.get('proxyPort');
        // Validation
        if ((proxyUrls || newUrlFunction) &&
            (groupsToUse.length || countryCodeToUse)) {
            this._throwCannotCombineCustomWithApify();
        }
        if (proxyUrls && newUrlFunction)
            this._throwCannotCombineCustomMethods();
        this.groups = groupsToUse;
        this.countryCode = countryCodeToUse;
        this.password = password;
        this.hostname = hostname;
        this.port = port;
        this.usesApifyProxy = !this.proxyUrls && !this.newUrlFunction;
        if (proxyUrls && proxyUrls.some((url) => url.includes('apify.com'))) {
            this.log.warning('Some Apify proxy features may work incorrectly. Please consider setting up Apify properties instead of `proxyUrls`.\n' +
                'See https://sdk.apify.com/docs/guides/proxy-management#apify-proxy-configuration');
        }
    }
    /**
     * Loads proxy password if token is provided and checks access to Apify Proxy and provided proxy groups
     * if Apify Proxy configuration is used.
     * Also checks if country has access to Apify Proxy groups if the country code is provided.
     *
     * You should use the {@link createProxyConfiguration} function to create a pre-initialized
     * `ProxyConfiguration` instance instead of calling this manually.
     */
    async initialize() {
        if (this.usesApifyProxy) {
            if (!this.password) {
                await this._setPasswordIfToken();
            }
            if (!this.password) {
                if (actor_js_1.Actor.isAtHome()) {
                    throw new Error(`Apify Proxy password must be provided using options.password or the "${consts_1.APIFY_ENV_VARS.PROXY_PASSWORD}" environment variable. ` +
                        `You can also provide your Apify token via the "${consts_1.APIFY_ENV_VARS.TOKEN}" environment variable, ` +
                        `so that the SDK can fetch the proxy password from Apify API, when ${consts_1.APIFY_ENV_VARS.PROXY_PASSWORD} is not defined`);
                }
                else {
                    this.log.warning(`No proxy password or token detected, running without proxy. To use Apify Proxy locally, ` +
                        `provide options.password or "${consts_1.APIFY_ENV_VARS.PROXY_PASSWORD}" environment variable. ` +
                        `You can also provide your Apify token via the "${consts_1.APIFY_ENV_VARS.TOKEN}" environment variable, ` +
                        `so that the SDK can fetch the proxy password from Apify API, when ${consts_1.APIFY_ENV_VARS.PROXY_PASSWORD} is not defined`);
                }
            }
            return this._checkAccess();
        }
        return true;
    }
    /**
     * This function creates a new {@link ProxyInfo} info object.
     * It is used by CheerioCrawler and PuppeteerCrawler to generate proxy URLs and also to allow the user to inspect
     * the currently used proxy via the requestHandler parameter `proxyInfo`.
     * Use it if you want to work with a rich representation of a proxy URL.
     * If you need the URL string only, use {@link ProxyConfiguration.newUrl}.
     * @param [sessionId]
     *  Represents the identifier of user {@link Session} that can be managed by the {@link SessionPool} or
     *  you can use the Apify Proxy [Session](https://docs.apify.com/proxy#sessions) identifier.
     *  When the provided sessionId is a number, it's converted to a string. Property sessionId of
     *  {@link ProxyInfo} is always returned as a type string.
     *
     *  All the HTTP requests going through the proxy with the same session identifier
     *  will use the same target proxy server (i.e. the same IP address).
     *  The identifier must not be longer than 50 characters and include only the following: `0-9`, `a-z`, `A-Z`, `"."`, `"_"` and `"~"`.
     * @return Represents information about used proxy and its configuration.
     */
    async newProxyInfo(sessionId, options) {
        if (typeof sessionId === 'number')
            sessionId = `${sessionId}`;
        (0, ow_1.default)(sessionId, ow_1.default.optional.string
            .maxLength(MAX_SESSION_ID_LENGTH)
            .matches(consts_1.APIFY_PROXY_VALUE_REGEX));
        const proxyInfo = await super.newProxyInfo(sessionId, options);
        if (!proxyInfo)
            return proxyInfo;
        const { groups, countryCode, password, port, hostname } = (this.usesApifyProxy ? this : new URL(proxyInfo.url));
        return {
            ...proxyInfo,
            sessionId,
            groups,
            countryCode,
            // this.password is not encoded, but the password from the URL will be, we need to normalize
            password: this.usesApifyProxy
                ? (password ?? '')
                : decodeURIComponent(password),
            hostname,
            port: port,
        };
    }
    /**
     * Returns a new proxy URL based on provided configuration options and the `sessionId` parameter.
     * @param [sessionId]
     *  Represents the identifier of user {@link Session} that can be managed by the {@link SessionPool} or
     *  you can use the Apify Proxy [Session](https://docs.apify.com/proxy#sessions) identifier.
     *  When the provided sessionId is a number, it's converted to a string.
     *
     *  All the HTTP requests going through the proxy with the same session identifier
     *  will use the same target proxy server (i.e. the same IP address).
     *  The identifier must not be longer than 50 characters and include only the following: `0-9`, `a-z`, `A-Z`, `"."`, `"_"` and `"~"`.
     * @return A string with a proxy URL, including authentication credentials and port number.
     *  For example, `http://bob:password123@proxy.example.com:8000`
     */
    async newUrl(sessionId, options) {
        if (typeof sessionId === 'number')
            sessionId = `${sessionId}`;
        (0, ow_1.default)(sessionId, ow_1.default.optional.string
            .maxLength(MAX_SESSION_ID_LENGTH)
            .matches(consts_1.APIFY_PROXY_VALUE_REGEX));
        if (this.newUrlFunction) {
            return ((await this._callNewUrlFunction(sessionId, {
                request: options?.request,
            })) ?? undefined);
        }
        if (this.proxyUrls) {
            return this._handleCustomUrl(sessionId);
        }
        if (this.tieredProxyUrls) {
            return (this._handleTieredUrl(sessionId ?? (0, utilities_1.cryptoRandomObjectId)(6), options).proxyUrl ?? undefined);
        }
        return this.composeDefaultUrl(sessionId);
    }
    _generateTieredProxyUrls(tieredProxyConfig, globalOptions) {
        return tieredProxyConfig.map((config) => [
            new ProxyConfiguration({
                ...globalOptions,
                ...config,
                tieredProxyConfig: undefined,
            }).composeDefaultUrl(),
        ]);
    }
    /**
     * Returns proxy username.
     */
    _getUsername(sessionId) {
        let username;
        const { groups, countryCode } = this;
        const parts = [];
        if (groups && groups.length) {
            parts.push(`groups-${groups.join('+')}`);
        }
        if (sessionId) {
            parts.push(`session-${sessionId}`);
        }
        if (countryCode) {
            parts.push(`country-${countryCode}`);
        }
        username = parts.join(',');
        if (parts.length === 0)
            username = 'auto';
        return username;
    }
    composeDefaultUrl(sessionId) {
        const username = this._getUsername(sessionId);
        const url = new URL(`http://${this.hostname}:${this.port}`);
        url.username = `${username}`;
        url.password = `${this.password}`;
        const urlString = url.toString();
        return urlString.substring(0, urlString.length - 1);
    }
    /**
     * Fetch & set the proxy password from Apify API if an Apify token is provided.
     */
    // TODO: Make this private
    async _setPasswordIfToken() {
        const token = this.config.get('token');
        if (!token)
            return;
        try {
            const user = await actor_js_1.Actor.apifyClient.user().get();
            this.password = user.proxy?.password;
        }
        catch (error) {
            if (actor_js_1.Actor.isAtHome()) {
                throw error;
            }
            else {
                this.log.warning(`Failed to fetch user data using token`, {
                    error,
                });
            }
        }
    }
    /**
     * Checks whether the user has access to the proxies specified in the provided ProxyConfigurationOptions.
     * If the check can not be made, it only prints a warning and allows the program to continue. This is to
     * prevent program crashes caused by short downtimes of Proxy.
     */
    async _checkAccess() {
        const status = await this._fetchStatus();
        if (!status) {
            this.log.warning('Apify Proxy access check timed out. Watch out for errors with status code 407. ' +
                "If you see some, it most likely means you don't have access to either all or some of the proxies you're trying to use.");
            return true;
        }
        const { connected, connectionError, isManInTheMiddle } = status;
        this.isManInTheMiddle = isManInTheMiddle;
        if (connected) {
            return true;
        }
        // Throw only on the platform, locally we just print a warning and run requests without the proxy.
        // This is because the user might not have set up things correctly yet.
        // It still fails on the platform, where we don't want to allow this behavior.
        if (actor_js_1.Actor.isAtHome()) {
            throw new Error(connectionError);
        }
        this.log.warning(connectionError);
        return false;
    }
    /**
     * Apify Proxy can be down for a second or a minute, but this should not crash processes.
     */
    async _fetchStatus() {
        const proxyStatusUrl = this.config.get('proxyStatusUrl', 'http://proxy.apify.com');
        const requestOpts = {
            url: `${proxyStatusUrl}/?format=json`,
            proxyUrl: await this.newUrl(),
            timeout: { request: CHECK_ACCESS_REQUEST_TIMEOUT_MILLIS },
            responseType: 'json',
        };
        for (let attempt = 1; attempt <= CHECK_ACCESS_MAX_ATTEMPTS; attempt++) {
            try {
                const response = await (0, utils_1.gotScraping)(requestOpts);
                return response.body;
            }
            catch {
                // retry connection errors
            }
        }
        return undefined;
    }
    /**
     * Throws cannot combine custom proxies with Apify Proxy
     * @internal
     */
    _throwCannotCombineCustomWithApify() {
        throw new Error('Cannot combine custom proxies with Apify Proxy! ' +
            'It is not allowed to set "options.proxyUrls" or "options.newUrlFunction" combined with ' +
            '"options.groups" or "options.apifyProxyGroups" and "options.countryCode" or "options.apifyProxyCountry".');
    }
}
exports.ProxyConfiguration = ProxyConfiguration;
//# sourceMappingURL=proxy_configuration.js.map